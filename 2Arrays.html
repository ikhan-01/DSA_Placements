<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Placement-Focused Arrays Page</title>
  <link rel="stylesheet" href="cssDSA.css">
</head>
<body>
  <div class="sidebar">
    <h2>Array Topics</h2>
    <a href="#reverse">Reverse Array</a>
    <a href="#rotate">Rotate Array</a>
    <a href="#max">Maximum Element</a>
    <a href="#subarray">Subarray Sum</a>
    <a href="#second">Second Largest</a>
    <a href="#mock1">Longest Increasing Subarray</a>
    <a href="#mock2">Pairs with Given Sum</a>
    <a href="#missing">Missing Number</a>
    <a href="#leaders">Leaders in Array</a>
    <a href="#dutch">Sort 0s, 1s, 2s</a>
    <a href="#majority">Majority Element</a>
    <a href="#merge">Merge Two Sorted Arrays</a>
    <a href="#equilibrium">Equilibrium Index</a>
    <a href="#nextgreater">Next Greater Element</a>
  </div>
  </div>

<div class="content" id="printable-content">
 
<button class="print-button" onclick="window.print()">üñ®Ô∏è Print</button>
<h1>Placement Preparation: Arrays</h1>    
<!-- Reverse Array -->
    <h2 id="reverse">Reverse Array</h2>
    <p><strong>Problem Statement:</strong> Given an array of integers, reverse the elements of the array in-place, i.e., without using extra space.</p>
    <h3>Brute-force Approach (Python)</h3>
    <pre><code>def reverse_array_brute(arr):
    result = []
    for i in range(len(arr) - 1, -1, -1):
        result.append(arr[i])
    return result</code></pre>
    <div class="explanation">Time: O(n), Space: O(n) ‚Äì New array created</div>
    <h3>Optimized Approach (Python)</h3>
    <pre><code>def reverse_array_optimized(arr):
    start, end = 0, len(arr) - 1
    while start < end:
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1
    return arr</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div> 
  </code></pre>

    <!-- Rotate Array -->
    <h2 id="rotate">Rotate Array</h2>
    <p><strong>Problem Statement:</strong> Given an array, rotate the elements to the right by k steps.</p>
    <h3>Brute-force Approach (Python)</h3>
    <pre><code>def rotate_array_brute(arr, k):
    k = k % len(arr)
    for _ in range(k):
        last = arr.pop()
        arr.insert(0, last)
    return arr</code></pre>
    <div class="explanation">Time: O(k*n), Space: O(1)</div>
    <h3>Optimized Approach (Python)</h3>
    <pre><code>def rotate_array_optimized(arr, k):
    k = k % len(arr)
    arr[:] = arr[-k:] + arr[:-k]
    return arr</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>
    </code></pre>

    <!-- Maximum Element -->
    <h2 id="max">Maximum Element</h2>
    <p><strong>Problem Statement:</strong> Find the maximum value in the array.</p>
    <h3>Brute-force Approach (Python)</h3>
    <pre><code>def find_max_brute(arr):
    max_val = arr[0]
    for num in arr:
        if num > max_val:
            max_val = num
    return max_val</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>
    <h3>Optimized Approach (Python)</h3>
    <pre><code>def find_max_optimized(arr):
    return max(arr)</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>
    </code></pre>

    <!-- Subarray Sum (Kadane's) -->
    <h2 id="subarray">Subarray Sum</h2>
    <p><strong>Problem Statement:</strong> Find the contiguous subarray with the maximum sum.</p>
    <h3>Brute-force Approach (Python)</h3>
    <pre><code>def max_subarray_sum_brute(arr):
    max_sum = float('-inf')
    for i in range(len(arr)):
        for j in range(i, len(arr)):
            max_sum = max(max_sum, sum(arr[i:j+1]))
    return max_sum</code></pre>
    <div class="explanation">Time: O(n^2), Space: O(1)</div>
    <h3>Optimized (Kadane's Algorithm, Python)</h3>
    <pre><code>def max_subarray_sum_kadane(arr):
    max_sum = curr_sum = arr[0]
    for num in arr[1:]:
        curr_sum = max(num, curr_sum + num)
        max_sum = max(max_sum, curr_sum)
    return max_sum</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>
    </code></pre>

    <!-- Second Largest -->
    <h2 id="second">Second Largest</h2>
    <p><strong>Problem Statement:</strong> Find the second largest element in the array.</p>
    <h3>Brute-force Approach (Python)</h3>
    <pre><code>def second_largest_brute(arr):
    arr = list(set(arr))
    arr.sort()
    return arr[-2]</code></pre>
    <div class="explanation">Time: O(n log n), Space: O(n)</div>
    <h3>Optimized Approach (Python)</h3>
    <pre><code>def second_largest_optimized(arr):
    first = second = float('-inf')
    for num in arr:
        if num > first:
            second, first = first, num
        elif num > second and num != first:
            second = num
    return second</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>
    </code></pre>

    <!-- Longest Increasing Subarray -->
    <h2 id="mock1">Longest Increasing Subarray</h2>
    <p><strong>Problem Statement:</strong> Find the length of the longest contiguous increasing subarray.</p>
    <pre><code>def longest_increasing_subarray(arr):
    max_len = cur_len = 1
    for i in range(1, len(arr)):
        if arr[i] > arr[i - 1]:
            cur_len += 1
            max_len = max(max_len, cur_len)
        else:
            cur_len = 1
    return max_len</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>

    <!-- Pairs with Given Sum -->
    <h2 id="mock2">Pairs with Given Sum</h2>
    <p><strong>Problem Statement:</strong> Find all pairs in the array that sum to a specific target value.</p>
    <pre><code>def find_pairs(arr, target):
    seen = set()
    result = []
    for num in arr:
        if target - num in seen:
            result.append((target - num, num))
        seen.add(num)
    return result</code></pre>

    <h2 id="missing">Missing Number</h2>
    <p><strong>Problem Statement:</strong> Given an array containing n distinct numbers taken from 0 to n, find the one number missing from the array.</p>
    <div class="testcase"><strong>Input:</strong> [3, 0, 1] <br><strong>Output:</strong> 2</div>
    <h3>Optimized (Python)</h3>
    <pre><code>def missing_number(arr):
    n = len(arr)
    total = n * (n + 1) // 2
    return total - sum(arr)</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>

    <h2 id="leaders">Leaders in Array</h2>
    <p><strong>Problem Statement:</strong> Print all leaders in the array. An element is a leader if it is greater than all elements to its right.</p>
    <div class="testcase"><strong>Input:</strong> [16, 17, 4, 3, 5, 2] <br><strong>Output:</strong> [17, 5, 2]</div>
    <h3>Python Approach</h3>
    <pre><code>def find_leaders(arr):
    n = len(arr)
    leaders = []
    max_from_right = arr[-1]
    leaders.append(max_from_right)
    for i in range(n - 2, -1, -1):
        if arr[i] > max_from_right:
            max_from_right = arr[i]
            leaders.append(max_from_right)
    return leaders[::-1]</code></pre>
    <div class="explanation">Time: O(n), Space: O(n)</div>

    <h2 id="dutch">Sort 0s, 1s, 2s (Dutch National Flag)</h2>
    <p><strong>Problem Statement:</strong> Given an array containing only 0s, 1s, and 2s, sort it in-place.</p>
    <div class="testcase"><strong>Input:</strong> [0, 1, 2, 0, 1, 2] <br><strong>Output:</strong> [0, 0, 1, 1, 2, 2]</div>
    <h3>Dutch National Flag Algorithm</h3>
    <pre><code>def sort012(arr):
    low, mid, high = 0, 0, len(arr) - 1
    while mid <= high:
        if arr[mid] == 0:
            arr[low], arr[mid] = arr[mid], arr[low]
            low += 1
            mid += 1
        elif arr[mid] == 1:
            mid += 1
        else:
            arr[mid], arr[high] = arr[high], arr[mid]
            high -= 1</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>

    <h2 id="majority">Majority Element</h2>
    <p><strong>Problem Statement:</strong> Find the element that appears more than ‚åän/2‚åã times (Moore‚Äôs Voting Algorithm).</p>
    <div class="testcase"><strong>Input:</strong> [3, 3, 4, 2, 3, 3, 3] <br><strong>Output:</strong> 3</div>
    <h3>Python Implementation</h3>
    <pre><code>def majority_element(arr):
    count = candidate = 0
    for num in arr:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>

    <h2 id="merge">Merge Two Sorted Arrays</h2>
    <p><strong>Problem Statement:</strong> Merge two sorted arrays into one sorted array.</p>
    <div class="testcase"><strong>Input:</strong> [1,3,5], [2,4,6] <br><strong>Output:</strong> [1,2,3,4,5,6]</div>
    <h3>Python Implementation</h3>
    <pre><code>def merge_sorted_arrays(a, b):
    result = []
    i = j = 0
    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            result.append(a[i])
            i += 1
        else:
            result.append(b[j])
            j += 1
    result.extend(a[i:])
    result.extend(b[j:])
    return result</code></pre>
    <div class="explanation">Time: O(n + m), Space: O(n + m)</div>

    <h2 id="equilibrium">Equilibrium Index</h2>
    <p><strong>Problem Statement:</strong> Find an index such that the sum of elements at lower indexes is equal to the sum at higher indexes.</p>
    <div class="testcase"><strong>Input:</strong> [-7, 1, 5, 2, -4, 3, 0] <br><strong>Output:</strong> 3</div>
    <h3>Python Implementation</h3>
    <pre><code>def equilibrium_index(arr):
    total = sum(arr)
    left_sum = 0
    for i, num in enumerate(arr):
        total -= num
        if left_sum == total:
            return i
        left_sum += num
    return -1</code></pre>
    <div class="explanation">Time: O(n), Space: O(1)</div>

    <h2 id="nextgreater">Next Greater Element</h2>
    <p><strong>Problem Statement:</strong> For each element, find the next greater element to its right. If none, return -1.</p>
    <div class="testcase"><strong>Input:</strong> [4, 5, 2, 25] <br><strong>Output:</strong> [5, 25, 25, -1]</div>
    <h3>Python Stack-based Approach</h3>
    <pre><code>def next_greater_elements(arr):
    result = [-1] * len(arr)
    stack = []
    for i in range(len(arr)):
        while stack and arr[i] > arr[stack[-1]]:
            result[stack.pop()] = arr[i]
        stack.append(i)
    return result</code></pre>
    <div class="explanation">Time: O(n), Space: O(n)</div>
    </div>
  </div>

</body>
</html>
